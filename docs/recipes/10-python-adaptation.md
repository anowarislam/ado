# Chapter 10: Python-Specific Patterns and Adaptation

> A comprehensive guide to adapting this CI/CD system for Python projects - from project structure to release automation.

## Table of Contents

- [Introduction](#introduction)
- [Python Project Structure](#python-project-structure)
- [Pyproject.toml Configuration](#pyprojecttoml-configuration)
- [Testing with Pytest](#testing-with-pytest)
- [Linting with Ruff](#linting-with-ruff)
- [Type Checking](#type-checking)
- [Virtual Environment Management](#virtual-environment-management)
- [Dependency Management](#dependency-management)
- [Makefile Patterns for Python](#makefile-patterns-for-python)
- [GitHub Actions for Python](#github-actions-for-python)
- [Release Automation for Python](#release-automation-for-python)
- [Container Patterns for Python](#container-patterns-for-python)
- [Adapting from Go Patterns](#adapting-from-go-patterns)
- [CLI Framework Comparison](#cli-framework-comparison)
- [Web Framework Patterns](#web-framework-patterns)
- [Data Science Projects](#data-science-projects)
- [Complete Example Project](#complete-example-project)

---

## Introduction

### Why This Chapter Exists

The core CI/CD system documented in this repository was built for a Go project, but the principles are language-agnostic. This chapter provides a complete adaptation guide for Python projects, translating every pattern, tool, and workflow into Python-specific equivalents.

### What You'll Learn

- How to structure Python projects for maximum maintainability
- Complete pyproject.toml configuration for modern Python (PEP 621+)
- Testing patterns with pytest that match Go's table-driven tests
- Ruff for linting and formatting (replaces black + flake8 + isort)
- Virtual environment and dependency management best practices
- Python-specific Makefile patterns
- GitHub Actions workflows optimized for Python
- Release automation to PyPI with trusted publishing
- Container best practices for Python applications
- Direct translation from Go patterns to Python equivalents

### Prerequisites

- Python 3.10+ (3.12+ recommended)
- Basic understanding of Python packaging
- Familiarity with the core CI/CD concepts from Chapters 1-7

---

## Python Project Structure

### Recommended Layout

Python projects can follow several layouts. Here's the recommended structure that mirrors the clarity of Go's organization:

```
myproject/
├── pyproject.toml              # Project metadata, dependencies, tool config
├── README.md                   # Project overview
├── LICENSE                     # License file
├── CHANGELOG.md                # Auto-generated by release-please
├── .gitignore                  # Python-specific ignores
├── Makefile                    # Build automation
│
├── src/                        # Source code (src-layout)
│   └── myproject/
│       ├── __init__.py         # Package initialization
│       ├── __main__.py         # Entry point for python -m myproject
│       ├── cli.py              # CLI commands
│       ├── config.py           # Configuration management
│       └── core/               # Core business logic
│           ├── __init__.py
│           ├── models.py
│           └── service.py
│
├── tests/                      # Test directory
│   ├── __init__.py
│   ├── conftest.py             # Pytest fixtures
│   ├── test_cli.py             # CLI tests
│   └── core/
│       ├── __init__.py
│       └── test_service.py
│
├── docs/                       # Documentation
│   ├── index.md
│   ├── adr/                    # Architecture Decision Records
│   ├── commands/               # Command specifications
│   └── features/               # Feature specifications
│
├── .github/
│   ├── workflows/
│   │   ├── ci.yml              # CI pipeline
│   │   └── release.yml         # Release automation
│   └── release-please-config.json
│
└── scripts/                    # Build and utility scripts
    ├── build.sh
    └── verify-release.sh
```

### Src-Layout vs Flat-Layout

**Src-Layout (Recommended)**:
```
myproject/
├── src/
│   └── myproject/
│       └── __init__.py
└── tests/
```

**Advantages**:

- Prevents accidental imports of non-installed code
- Clearly separates source from tests
- Forces proper package installation
- Recommended by PyPA (Python Packaging Authority)

**Flat-Layout (Simpler)**:
```
myproject/
├── myproject/
│   └── __init__.py
└── tests/
```

**Use When**:

- Small projects or libraries
- Prototyping
- Educational projects

**For this chapter, we'll use src-layout** as it scales better and prevents common testing pitfalls.

### Application vs Library Structure

**CLI Application**:
```python
# src/myproject/cli.py
def main():
    """Entry point for CLI."""
    pass

# pyproject.toml
[project.scripts]
myproject = "myproject.cli:main"
```

**Importable Library**:
```python
# src/myproject/__init__.py
from .core import MyClass, my_function

__all__ = ["MyClass", "my_function"]
```

### File Naming Conventions

```
module.py          # Single module
models.py          # Data models
config.py          # Configuration
exceptions.py      # Custom exceptions
constants.py       # Constants
utils.py           # Utilities (avoid if possible, prefer specific modules)

test_module.py     # Tests for module.py
conftest.py        # Pytest configuration and fixtures
```

---

## Pyproject.toml Configuration

### Complete Modern Configuration

The `pyproject.toml` file is the single source of truth for modern Python projects (PEP 621). Here's a complete, production-ready configuration with every section explained:

```toml
# =============================================================================
# Project Metadata (PEP 621)
# =============================================================================
[project]
name = "myproject"
version = "0.0.0"  # Managed by release-please
description = "A production-ready Python CLI application"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "you@example.com"}
]
maintainers = [
    {name = "Your Name", email = "you@example.com"}
]
keywords = ["cli", "automation", "tool"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Utilities",
]

# Runtime dependencies
dependencies = [
    "click>=8.1.0",        # CLI framework
    "pyyaml>=6.0.0",       # YAML parsing
    "requests>=2.31.0",    # HTTP requests
    "rich>=13.0.0",        # Terminal formatting
]

# Optional dependency groups
[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
    "pytest-mock>=3.12.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
    "types-pyyaml>=6.0.0",
    "types-requests>=2.31.0",
]
docs = [
    "mkdocs>=1.5.0",
    "mkdocs-material>=9.5.0",
]
all = [
    "myproject[dev,docs]",  # Install everything
]

# Entry points for CLI commands
[project.scripts]
myproject = "myproject.cli:main"
myproject-admin = "myproject.admin:main"

# URLs for project
[project.urls]
Homepage = "https://github.com/yourusername/myproject"
Documentation = "https://myproject.readthedocs.io"
Repository = "https://github.com/yourusername/myproject"
Issues = "https://github.com/yourusername/myproject/issues"
Changelog = "https://github.com/yourusername/myproject/blob/main/CHANGELOG.md"

# =============================================================================
# Build System (PEP 517/518)
# =============================================================================
[build-system]
requires = ["setuptools>=68.0.0", "wheel"]
build-backend = "setuptools.build_meta"

# Setuptools configuration
[tool.setuptools]
# Automatically discover packages in src/
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]
include = ["myproject*"]
exclude = ["tests*"]

# Include non-Python files in package
[tool.setuptools.package-data]
myproject = ["py.typed", "*.yaml", "*.json"]

# =============================================================================
# Ruff - Linting and Formatting
# =============================================================================
[tool.ruff]
# Output
output-format = "concise"
line-length = 100
target-version = "py310"

# File selection
src = ["src", "tests"]
extend-exclude = [
    ".venv",
    "venv",
    "*.egg-info",
    "build",
    "dist",
    ".pytest_cache",
    "__pycache__",
]

[tool.ruff.lint]
# Rule sets to enable
select = [
    "E",     # pycodestyle errors
    "W",     # pycodestyle warnings
    "F",     # pyflakes
    "I",     # isort (import sorting)
    "N",     # pep8-naming
    "UP",    # pyupgrade
    "B",     # flake8-bugbear
    "C4",    # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "T10",   # flake8-debugger
    "EM",    # flake8-errmsg
    "ISC",   # flake8-implicit-str-concat
    "ICN",   # flake8-import-conventions
    "G",     # flake8-logging-format
    "PIE",   # flake8-pie
    "T20",   # flake8-print
    "PT",    # flake8-pytest-style
    "Q",     # flake8-quotes
    "RSE",   # flake8-raise
    "RET",   # flake8-return
    "SIM",   # flake8-simplify
    "TCH",   # flake8-type-checking
    "ARG",   # flake8-unused-arguments
    "PTH",   # flake8-use-pathlib
    "ERA",   # eradicate (commented-out code)
    "PL",    # pylint
    "RUF",   # Ruff-specific rules
]

# Rules to ignore
ignore = [
    "E501",   # Line too long (handled by formatter)
    "PLR0913", # Too many arguments
    "PLR2004", # Magic value used in comparison
]

# Allow autofix for these rules
fixable = ["ALL"]
unfixable = []

# Allow unused variables starting with underscore
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"

[tool.ruff.lint.per-file-ignores]
# Tests can have magic values, assertions, etc.
"tests/**/*" = ["PLR2004", "S101", "ARG"]
# __init__.py can have unused imports
"__init__.py" = ["F401"]

[tool.ruff.lint.isort]
known-first-party = ["myproject"]
force-single-line = false
lines-after-imports = 2

[tool.ruff.lint.mccabe]
max-complexity = 10

[tool.ruff.lint.pydocstyle]
convention = "google"  # or "numpy", "pep257"

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

# =============================================================================
# Pytest - Testing
# =============================================================================
[tool.pytest.ini_options]
minversion = "8.0"
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]

# Output options
addopts = [
    "-ra",                    # Show summary of all test outcomes
    "--strict-markers",       # Error on unknown markers
    "--strict-config",        # Error on unknown config
    "--showlocals",           # Show local variables in tracebacks
    "-v",                     # Verbose
]

# Coverage settings
[tool.coverage.run]
source = ["src"]
branch = true
parallel = true
omit = [
    "tests/*",
    "*/site-packages/*",
]

[tool.coverage.report]
precision = 2
show_missing = true
skip_covered = false
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "@abstractmethod",
]

# Coverage thresholds
fail_under = 80.0

[tool.coverage.html]
directory = "coverage_html"

# =============================================================================
# Mypy - Type Checking
# =============================================================================
[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_any_generics = true
check_untyped_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
strict_equality = true
show_error_codes = true

# Per-module options
[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false

[[tool.mypy.overrides]]
module = [
    "pytest.*",
    "click.*",
]
ignore_missing_imports = true
```

### Key Sections Explained

**Project Metadata**:

- `version = "0.0.0"`: Managed by release-please; update only in releases
- `requires-python`: Minimum Python version (use 3.10+ for modern features)
- `dependencies`: Runtime requirements only
- `optional-dependencies`: Dev tools, docs tools, etc.

**Build System**:

- `setuptools>=68.0.0`: Modern setuptools with PEP 621 support
- `package-dir`: Use src-layout
- `package-data`: Include type stubs (py.typed), configs, etc.

**Ruff Configuration**:

- Replaces black, flake8, isort, and more
- `select`: Enable specific rule sets
- `ignore`: Disable problematic rules
- `per-file-ignores`: Different rules for tests

**Pytest**:

- `testpaths`: Where to find tests
- `addopts`: Default CLI options
- Coverage thresholds: 80% minimum (matches Go CI)

**Mypy**:

- Strict type checking enabled
- Per-module overrides for tests and third-party packages

### Version Management

Version is managed by release-please. The workflow:

1. Conventional commits → Release PR created
2. Merge Release PR → Version bumped in `pyproject.toml`
3. GitHub Release created → CI builds and publishes to PyPI

Never manually edit the version number.

---

## Testing with Pytest

### Basic Test Structure

Python's pytest is equivalent to Go's testing package. Here's how to adapt patterns:

**Go Test**:
```go
func TestCalculate(t *testing.T) {
    result := Calculate(2, 3)
    if result != 5 {
        t.Errorf("expected 5, got %d", result)
    }
}
```

**Python Test**:
```python
def test_calculate():
    result = calculate(2, 3)
    assert result == 5
```

### Table-Driven Tests with Parametrize

**Go Pattern**:
```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
        {"zero", 0, 0, 0},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("got %d, want %d", got, tt.want)
            }
        })
    }
}
```

**Python Equivalent**:
```python
import pytest

@pytest.mark.parametrize(
    "a,b,expected",
    [
        pytest.param(2, 3, 5, id="positive"),
        pytest.param(-1, -1, -2, id="negative"),
        pytest.param(0, 0, 0, id="zero"),
    ],
)
def test_add(a, b, expected):
    result = add(a, b)
    assert result == expected
```

### Fixtures for Test Setup

**conftest.py** (shared fixtures):
```python
# tests/conftest.py
import pytest
from pathlib import Path
from click.testing import CliRunner

@pytest.fixture
def temp_config(tmp_path: Path):
    """Create a temporary config file."""
    config = tmp_path / "config.yaml"
    config.write_text("""
    log_level: info
    output: text
    """)
    return config

@pytest.fixture
def cli_runner():
    """Provide a Click CLI test runner."""
    return CliRunner()

@pytest.fixture
def mock_api(mocker):
    """Mock external API calls."""
    return mocker.patch("myproject.api.fetch_data")
```

**Using fixtures**:
```python
# tests/test_config.py
def test_load_config(temp_config):
    """Test loading configuration from file."""
    config = load_config(temp_config)
    assert config.log_level == "info"
    assert config.output == "text"

def test_config_missing_file(tmp_path):
    """Test error when config file doesn't exist."""
    with pytest.raises(FileNotFoundError):
        load_config(tmp_path / "nonexistent.yaml")
```

### Testing CLI Applications

**Using Click's CliRunner**:
```python
# tests/test_cli.py
from click.testing import CliRunner
from myproject.cli import cli

def test_echo_command():
    """Test basic echo command."""
    runner = CliRunner()
    result = runner.invoke(cli, ["echo", "hello"])

    assert result.exit_code == 0
    assert "hello" in result.output

def test_echo_with_flags():
    """Test echo with transformation flags."""
    runner = CliRunner()
    result = runner.invoke(cli, ["echo", "--upper", "hello"])

    assert result.exit_code == 0
    assert "HELLO" in result.output

def test_echo_json_output():
    """Test JSON output format."""
    runner = CliRunner()
    result = runner.invoke(cli, ["echo", "--output", "json", "hello"])

    assert result.exit_code == 0
    data = json.loads(result.output)
    assert data["message"] == "hello"

def test_invalid_flag_combination():
    """Test error handling for invalid flags."""
    runner = CliRunner()
    result = runner.invoke(cli, ["echo", "--upper", "--lower", "hello"])

    assert result.exit_code != 0
    assert "cannot use --upper and --lower together" in result.output
```

### Testing with Temporary Files

```python
def test_file_processing(tmp_path: Path):
    """Test file processing with temporary directory."""
    # Create test input
    input_file = tmp_path / "input.txt"
    input_file.write_text("test data")

    # Run processing
    output_file = tmp_path / "output.txt"
    process_file(input_file, output_file)

    # Verify output
    assert output_file.exists()
    assert output_file.read_text() == "PROCESSED: test data"
```

### Mock External Dependencies

```python
# tests/test_api.py
import pytest
from unittest.mock import Mock, patch

def test_fetch_user_data(mocker):
    """Test API call with mocked response."""
    # Mock the requests.get call
    mock_response = Mock()
    mock_response.json.return_value = {"name": "John", "id": 123}
    mock_response.status_code = 200

    mocker.patch("requests.get", return_value=mock_response)

    # Test the function
    user = fetch_user_data(123)
    assert user["name"] == "John"
    assert user["id"] == 123

@pytest.fixture
def mock_db_connection(mocker):
    """Mock database connection."""
    mock_conn = mocker.Mock()
    mock_cursor = mocker.Mock()
    mock_cursor.fetchall.return_value = [("row1",), ("row2",)]
    mock_conn.cursor.return_value = mock_cursor
    return mock_conn

def test_database_query(mock_db_connection):
    """Test database query with mocked connection."""
    results = run_query(mock_db_connection, "SELECT * FROM users")
    assert len(results) == 2
    assert results[0] == ("row1",)
```

### Coverage Configuration

Run tests with coverage:
```bash
# Basic coverage
pytest --cov=src --cov-report=term-missing

# HTML report
pytest --cov=src --cov-report=html

# Fail if below threshold (80%)
pytest --cov=src --cov-fail-under=80
```

Output example:
```
----------- coverage: platform linux, python 3.12 -----------
Name                     Stmts   Miss  Cover   Missing
------------------------------------------------------
src/myproject/cli.py        45      2    96%   78-79
src/myproject/config.py     32      0   100%
src/myproject/core.py       89      5    94%   45, 67-70
------------------------------------------------------
TOTAL                      166      7    96%
```

### Advanced Pytest Patterns

**Markers for test organization**:
```python
# pyproject.toml
[tool.pytest.ini_options]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: integration tests",
    "unit: unit tests",
]

# tests/test_slow.py
@pytest.mark.slow
def test_large_dataset_processing():
    """Process large dataset (slow test)."""
    pass

# Run only fast tests
# pytest -m "not slow"

# Run only integration tests
# pytest -m integration
```

**Assertions with custom messages**:
```python
def test_complex_validation():
    result = complex_calculation(10, 20)
    assert result == 30, f"Expected 30 but got {result} for inputs (10, 20)"
```

**Testing exceptions**:
```python
def test_invalid_input():
    """Test that invalid input raises ValueError."""
    with pytest.raises(ValueError, match="must be positive"):
        calculate_square_root(-1)
```

**Snapshot testing for complex output**:
```python
# Requires pytest-snapshot
def test_report_generation(snapshot):
    """Test generated report matches snapshot."""
    report = generate_report({"users": 100, "revenue": 50000})
    snapshot.assert_match(report)
```

---

## Linting with Ruff

### Why Ruff?

Ruff is a modern Python linter written in Rust that replaces multiple tools:

| Old Tool | What It Did | Ruff Equivalent |
|----------|-------------|-----------------|
| black | Code formatting | `ruff format` |
| flake8 | Style linting | `ruff check --select=E,F,W` |
| isort | Import sorting | `ruff check --select=I` |
| pydocstyle | Docstring linting | `ruff check --select=D` |
| pyupgrade | Upgrade syntax | `ruff check --select=UP` |
| autoflake | Remove unused imports | `ruff check --fix` |

**Performance**: Ruff is 10-100x faster than the tools it replaces.

### Complete Ruff Setup

**Install**:
```bash
pip install ruff
```

**Basic usage**:
```bash
# Check for issues
ruff check .

# Auto-fix issues
ruff check --fix .

# Format code
ruff format .

# Check and format in one step
ruff check --fix . && ruff format .
```

### Rule Categories

```toml
[tool.ruff.lint]
select = [
    # Default
    "E",   # pycodestyle errors
    "F",   # pyflakes
    "W",   # pycodestyle warnings

    # Recommended additions
    "I",   # isort
    "N",   # pep8-naming
    "UP",  # pyupgrade
    "B",   # flake8-bugbear (catches common bugs)

    # Advanced
    "C4",  # flake8-comprehensions
    "SIM", # flake8-simplify
    "TCH", # flake8-type-checking
    "RUF", # Ruff-specific rules
]
```

### Common Rules and Fixes

**E501: Line too long**:
```python
# Before
some_function_call(argument1, argument2, argument3, argument4, argument5, argument6)

# After (ruff format)
some_function_call(
    argument1,
    argument2,
    argument3,
    argument4,
    argument5,
    argument6,
)
```

**F401: Unused import**:
```python
# Before
import sys
import os  # Unused
from pathlib import Path

# After (ruff check --fix)
import sys
from pathlib import Path
```

**I001: Import sorting**:
```python
# Before
from myproject.utils import helper
import sys
from pathlib import Path
import os

# After (ruff check --fix --select=I)
import os
import sys
from pathlib import Path

from myproject.utils import helper
```

**B006: Mutable default argument**:
```python
# Before (bug!)
def process_items(items=[]):  # Shared mutable default
    items.append("new")
    return items

# After
def process_items(items=None):
    if items is None:
        items = []
    items.append("new")
    return items
```

**SIM108: Use ternary operator**:
```python
# Before
if condition:
    value = "yes"
else:
    value = "no"

# After
value = "yes" if condition else "no"
```

### Per-File Configuration

```toml
[tool.ruff.lint.per-file-ignores]
# Tests can have magic values, asserts, etc.
"tests/**/*" = [
    "PLR2004",  # Magic value used in comparison
    "S101",     # Use of assert detected
    "ARG001",   # Unused function argument
]

# __init__.py files often have unused imports (re-exports)
"__init__.py" = ["F401"]

# Scripts can print and have one-off logic
"scripts/**/*" = ["T201"]
```

### Ruff vs Black

If you're coming from Black:

**Black**:
```toml
[tool.black]
line-length = 100
target-version = ['py310']
```

**Ruff (equivalent)**:
```toml
[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

Ruff's formatter is Black-compatible, so migration is seamless.

### Integration with Make

```makefile
# make/python.mk
.PHONY: py.lint py.lint.fix py.fmt

py.lint: ## Check code with ruff
	ruff check .

py.lint.fix: ## Auto-fix linting issues
	ruff check --fix .

py.fmt: ## Format code with ruff
	ruff format .

py.validate: py.lint py.test ## Run linting and tests
```

---

## Type Checking

### Mypy vs Pyright

| Feature | Mypy | Pyright |
|---------|------|---------|
| Speed | Moderate | Fast (written in TypeScript) |
| Strictness | Configurable | Very strict by default |
| IDE Support | Good | Excellent (VSCode default) |
| Ecosystem | Mature | Growing |
| Config | pyproject.toml | pyproject.toml or pyrightconfig.json |

**Recommendation**: Start with mypy for compatibility with existing projects. Use pyright for new projects with strict typing.

### Mypy Configuration

```toml
[tool.mypy]
# Basic settings
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true

# Strict mode (recommended)
disallow_untyped_defs = true
disallow_any_generics = true
check_untyped_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
strict_equality = true

# Output
show_error_codes = true
pretty = true

# Per-module configuration
[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false

[[tool.mypy.overrides]]
module = ["third_party.*", "untyped_lib.*"]
ignore_missing_imports = true
```

### Pyright Configuration

```toml
[tool.pyright]
include = ["src"]
exclude = [
    "**/__pycache__",
    ".venv",
]
pythonVersion = "3.10"
typeCheckingMode = "strict"

reportMissingImports = true
reportMissingTypeStubs = false
```

### Adding Type Hints

**Basic types**:
```python
def greet(name: str) -> str:
    return f"Hello, {name}"

def calculate(a: int, b: int) -> int:
    return a + b

numbers: list[int] = [1, 2, 3]
mapping: dict[str, int] = {"a": 1, "b": 2}
```

**Optional and Union**:
```python
from typing import Optional, Union

def find_user(user_id: int) -> Optional[User]:
    """Returns User or None if not found."""
    return db.get(user_id)

def parse_value(value: Union[str, int]) -> int:
    """Accepts str or int, returns int."""
    if isinstance(value, str):
        return int(value)
    return value
```

**Type aliases**:
```python
from typing import TypeAlias

UserId: TypeAlias = int
UserDict: TypeAlias = dict[str, str | int]

def get_user(user_id: UserId) -> UserDict:
    return {"id": user_id, "name": "John"}
```

**Generic types**:
```python
from typing import TypeVar, Generic

T = TypeVar("T")

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []

    def push(self, item: T) -> None:
        self._items.append(item)

    def pop(self) -> T:
        return self._items.pop()
```

**Protocol (structural typing)**:
```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None:
        ...

def render(obj: Drawable) -> None:
    """Accepts any object with a draw() method."""
    obj.draw()
```

### Type Stub Files

For libraries without type hints, create stub files:

```python
# stubs/untyped_lib.pyi
def process_data(data: str) -> dict[str, int]: ...

class Client:
    def __init__(self, url: str) -> None: ...
    def fetch(self) -> list[str]: ...
```

### When to Use Type Checking

**Always use for**:

- Public libraries
- Large codebases
- Team projects
- Critical business logic

**Optional for**:

- Small scripts
- Prototypes
- Data science notebooks (though gradually adding types helps)

---

## Virtual Environment Management

### Venv (Standard Library)

**Pros**: Built-in, no installation needed
**Cons**: Manual dependency management

```bash
# Create virtual environment
python3 -m venv .venv

# Activate
source .venv/bin/activate  # Linux/macOS
.venv\Scripts\activate.bat # Windows

# Install dependencies
pip install -e ".[dev]"

# Deactivate
deactivate
```

### Poetry

**Pros**: Dependency resolution, lock files, publishing
**Cons**: Slower, adds complexity

```bash
# Install poetry
curl -sSL https://install.python-poetry.org | python3 -

# Initialize project
poetry init

# Install dependencies
poetry install

# Add dependency
poetry add requests

# Add dev dependency
poetry add --group dev pytest

# Run command in venv
poetry run pytest

# Activate shell
poetry shell
```

**pyproject.toml**:
```toml
[tool.poetry]
name = "myproject"
version = "0.1.0"
description = ""

[tool.poetry.dependencies]
python = "^3.10"
click = "^8.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.0.0"
ruff = "^0.1.0"
```

### Pipenv

**Pros**: Combines pip + venv
**Cons**: Slower than pip, less actively maintained than Poetry

```bash
# Install pipenv
pip install pipenv

# Install dependencies
pipenv install

# Install dev dependencies
pipenv install --dev pytest

# Run command
pipenv run pytest

# Activate shell
pipenv shell
```

### Comparison Table

| Feature | venv + pip | Poetry | Pipenv |
|---------|-----------|--------|--------|
| Speed | Fast | Slow | Moderate |
| Lock files | No (need pip-tools) | Yes | Yes |
| Dependency resolution | No | Yes | Yes |
| Publishing | Manual | Built-in | No |
| Learning curve | Low | Medium | Medium |
| Adoption | Universal | Growing | Declining |

**Recommendation**:

- **Small projects / scripts**: venv + pip
- **Libraries / published packages**: Poetry
- **This CI/CD system**: venv + pip (simplicity, speed, CI-friendly)

---

## Dependency Management

### Requirements.txt vs Pyproject.toml

**requirements.txt** (old style):
```txt
click==8.1.7
pyyaml==6.0.1
requests==2.31.0
```

**pyproject.toml** (modern):
```toml
[project]
dependencies = [
    "click>=8.1.0",
    "pyyaml>=6.0.0",
    "requests>=2.31.0",
]
```

**Recommendation**: Use pyproject.toml for project metadata, generate requirements.txt for CI/deployment.

### Pinning Strategies

**Loose pinning** (libraries):
```toml
dependencies = [
    "click>=8.1.0",      # Allow minor updates
    "pyyaml>=6.0.0",
]
```

**Strict pinning** (applications):
```txt
# requirements.txt (generated from pip freeze)
click==8.1.7
pyyaml==6.0.1
requests==2.31.0
certifi==2024.2.2
```

**Lock files**:
```bash
# Generate lock file
pip freeze > requirements.lock

# Install from lock
pip install -r requirements.lock
```

### Multi-Environment Dependencies

```toml
[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
]
docs = [
    "mkdocs>=1.5.0",
    "mkdocs-material>=9.5.0",
]
prod = [
    "gunicorn>=21.0.0",  # WSGI server
    "psycopg2>=2.9.0",   # PostgreSQL
]
```

Install combinations:
```bash
# Dev environment
pip install -e ".[dev]"

# Production
pip install ".[prod]"

# Everything
pip install -e ".[dev,docs,prod]"
```

### Handling Platform-Specific Dependencies

```toml
[project]
dependencies = [
    "pywin32>=306; sys_platform == 'win32'",
    "uvloop>=0.19.0; sys_platform != 'win32'",
]
```

### Security: Dependabot Configuration

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    groups:
      pytest:
        patterns:
          - "pytest*"
      ruff:
        patterns:
          - "ruff"
```

---

## Makefile Patterns for Python

### Complete python.mk Implementation

```makefile
# ==============================================================================
# Python Development Targets
# ==============================================================================
# Full-featured Python development automation

# ------------------------------------------------------------------------------
# Variables
# ------------------------------------------------------------------------------
PYTHON ?= python3
VENV := .venv
VENV_BIN := $(VENV)/bin
PIP := $(VENV_BIN)/pip
PYTEST := $(VENV_BIN)/pytest
RUFF := $(VENV_BIN)/ruff
MYPY := $(VENV_BIN)/mypy

# Source directories
SRC_DIR := src
TEST_DIR := tests
PACKAGE := myproject

# Python version check
PYTHON_MIN_VERSION := 3.10

# ------------------------------------------------------------------------------
# Color Output
# ------------------------------------------------------------------------------
COLOR_RESET := \033[0m
COLOR_BOLD := \033[1m
COLOR_GREEN := \033[32m
COLOR_YELLOW := \033[33m
COLOR_RED := \033[31m

define log_info
	@echo "$(COLOR_BOLD)$(COLOR_YELLOW)→$(COLOR_RESET) $(1)"
endef

define log_success
	@echo "$(COLOR_BOLD)$(COLOR_GREEN)✓$(COLOR_RESET) $(1)"
endef

define log_error
	@echo "$(COLOR_BOLD)$(COLOR_RED)✗$(COLOR_RESET) $(1)"
endef

# ------------------------------------------------------------------------------
# Environment Setup
# ------------------------------------------------------------------------------
.PHONY: venv venv.clean install install.dev

venv: ## Create Python virtual environment
	$(call log_info,"Creating virtual environment...")
	@if [ ! -d "$(VENV)" ]; then \
		$(PYTHON) -m venv $(VENV); \
		$(PIP) install --upgrade pip setuptools wheel; \
	fi
	$(call log_success,"Virtual environment ready: $(VENV)")

venv.clean: ## Remove virtual environment
	$(call log_info,"Removing virtual environment...")
	@rm -rf $(VENV)
	$(call log_success,"Virtual environment removed")

install: venv ## Install package and dependencies
	$(call log_info,"Installing package...")
	@$(PIP) install -e .
	$(call log_success,"Package installed")

install.dev: venv ## Install with dev dependencies
	$(call log_info,"Installing dev dependencies...")
	@$(PIP) install -e ".[dev]"
	$(call log_success,"Dev dependencies installed")

# ------------------------------------------------------------------------------
# Code Quality
# ------------------------------------------------------------------------------
.PHONY: lint lint.fix fmt type check

lint: venv ## Run ruff linter
	$(call log_info,"Running linter...")
	@$(RUFF) check $(SRC_DIR) $(TEST_DIR)
	$(call log_success,"Linting passed")

lint.fix: venv ## Auto-fix linting issues
	$(call log_info,"Fixing linting issues...")
	@$(RUFF) check --fix $(SRC_DIR) $(TEST_DIR)
	$(call log_success,"Linting issues fixed")

fmt: venv ## Format code with ruff
	$(call log_info,"Formatting code...")
	@$(RUFF) format $(SRC_DIR) $(TEST_DIR)
	$(call log_success,"Code formatted")

type: venv ## Run type checking
	$(call log_info,"Running type checker...")
	@$(MYPY) $(SRC_DIR)
	$(call log_success,"Type checking passed")

check: lint type ## Run all checks (lint + type)

# ------------------------------------------------------------------------------
# Testing
# ------------------------------------------------------------------------------
.PHONY: test test.unit test.integration test.cover test.cover.html

test: venv ## Run all tests
	$(call log_info,"Running tests...")
	@$(PYTEST) $(TEST_DIR) -v
	$(call log_success,"All tests passed")

test.unit: venv ## Run unit tests only
	$(call log_info,"Running unit tests...")
	@$(PYTEST) $(TEST_DIR) -v -m "not integration"
	$(call log_success,"Unit tests passed")

test.integration: venv ## Run integration tests only
	$(call log_info,"Running integration tests...")
	@$(PYTEST) $(TEST_DIR) -v -m integration
	$(call log_success,"Integration tests passed")

test.cover: venv ## Run tests with coverage
	$(call log_info,"Running tests with coverage...")
	@$(PYTEST) $(TEST_DIR) \
		--cov=$(SRC_DIR) \
		--cov-report=term-missing \
		--cov-fail-under=80
	$(call log_success,"Coverage threshold met")

test.cover.html: venv ## Generate HTML coverage report
	$(call log_info,"Generating coverage report...")
	@$(PYTEST) $(TEST_DIR) \
		--cov=$(SRC_DIR) \
		--cov-report=html
	$(call log_success,"Coverage report: coverage_html/index.html")

# ------------------------------------------------------------------------------
# Build & Distribution
# ------------------------------------------------------------------------------
.PHONY: build build.clean dist

build: venv ## Build distribution packages
	$(call log_info,"Building distribution...")
	@$(VENV_BIN)/python -m build
	$(call log_success,"Distribution built: dist/")

build.clean: ## Remove build artifacts
	$(call log_info,"Cleaning build artifacts...")
	@rm -rf build/ dist/ *.egg-info
	@find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@find . -type f -name "*.pyo" -delete 2>/dev/null || true
	$(call log_success,"Build artifacts removed")

dist: build ## Alias for build

# ------------------------------------------------------------------------------
# Development Tools
# ------------------------------------------------------------------------------
.PHONY: repl shell deps.update docs.serve

repl: venv ## Start Python REPL with package loaded
	$(call log_info,"Starting REPL...")
	@$(VENV_BIN)/python

shell: venv ## Activate virtual environment
	@echo "Run: source $(VENV)/bin/activate"

deps.update: venv ## Update dependencies
	$(call log_info,"Updating dependencies...")
	@$(PIP) install --upgrade pip setuptools wheel
	@$(PIP) install --upgrade -e ".[dev]"
	$(call log_success,"Dependencies updated")

docs.serve: venv ## Serve documentation locally
	$(call log_info,"Starting docs server...")
	@$(VENV_BIN)/mkdocs serve

# ------------------------------------------------------------------------------
# CI/CD Targets
# ------------------------------------------------------------------------------
.PHONY: ci ci.test ci.lint

ci.test: install.dev test.cover ## CI: Install and test with coverage
	$(call log_success,"CI tests completed")

ci.lint: install.dev check ## CI: Install and run checks
	$(call log_success,"CI linting completed")

ci: ci.lint ci.test build ## CI: Full pipeline
	$(call log_success,"CI pipeline completed")

# ------------------------------------------------------------------------------
# Cleanup
# ------------------------------------------------------------------------------
.PHONY: clean clean.all

clean: build.clean ## Remove build artifacts and cache
	$(call log_info,"Cleaning cache...")
	@rm -rf .pytest_cache .mypy_cache .ruff_cache
	@rm -rf coverage_html htmlcov .coverage*
	$(call log_success,"Cache cleaned")

clean.all: clean venv.clean ## Remove everything (including venv)
	$(call log_success,"Full cleanup completed")

# ------------------------------------------------------------------------------
# Help
# ------------------------------------------------------------------------------
.PHONY: help

help: ## Show this help message
	@echo "$(COLOR_BOLD)Available targets:$(COLOR_RESET)"
	@grep -E '^[a-zA-Z_.-]+:.*?## .*$$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  $(COLOR_GREEN)%-20s$(COLOR_RESET) %s\n", $$1, $$2}'

.DEFAULT_GOAL := help
```

### Usage Examples

```bash
# Initial setup
make install.dev

# Development workflow
make fmt           # Format code
make lint          # Check linting
make test          # Run tests
make test.cover    # Run with coverage

# Full validation (pre-commit)
make ci

# Build package
make build

# Cleanup
make clean
make clean.all  # Including venv
```

### Integration with Root Makefile

```makefile
# Makefile (root)
include make/python.mk

.PHONY: validate
validate: ci.lint ci.test ## Full validation
	@echo "Validation complete"
```

---

## GitHub Actions for Python

### Complete CI Workflow

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"
          cache-dependency-path: pyproject.toml

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ruff mypy

      - name: Run ruff
        run: ruff check .

      - name: Run mypy
        run: mypy src/

  test:
    name: Test Python ${{ matrix.python-version }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ["3.10", "3.11", "3.12"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"
          cache-dependency-path: pyproject.toml

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Run tests
        run: |
          pytest tests/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=80

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-${{ matrix.os }}-${{ matrix.python-version }}
        if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.12'

  build:
    name: Build Distribution
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build distribution
        run: python -m build

      - name: Check distribution
        run: twine check dist/*

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
```

### Caching Strategies

**Cache pip packages**:
```yaml
- name: Set up Python
  uses: actions/setup-python@v5
  with:
    python-version: "3.12"
    cache: "pip"
    cache-dependency-path: pyproject.toml
```

**Cache with Poetry**:
```yaml
- name: Cache Poetry
  uses: actions/cache@v4
  with:
    path: ~/.cache/pypoetry
    key: poetry-${{ hashFiles('poetry.lock') }}
```

**Manual pip cache**:
```yaml
- name: Cache pip
  uses: actions/cache@v4
  with:
    path: ~/.cache/pip
    key: pip-${{ hashFiles('pyproject.toml') }}
```

### Matrix Testing

**Test multiple Python versions**:
```yaml
strategy:
  matrix:
    python-version: ["3.10", "3.11", "3.12"]
    os: [ubuntu-latest, windows-latest, macos-latest]
```

**Test with different dependency versions**:
```yaml
strategy:
  matrix:
    include:
      - python-version: "3.10"
        dependencies: "minimal"
      - python-version: "3.12"
        dependencies: "latest"

steps:
  - name: Install dependencies
    run: |
      if [ "${{ matrix.dependencies }}" == "minimal" ]; then
        pip install -e ".[dev]" --constraint constraints-minimal.txt
      else
        pip install -e ".[dev]"
      fi
```

---

## Release Automation for Python

### Release-Please Configuration

```json
{
  "release-type": "python",
  "package-name": "myproject",
  "bump-minor-pre-major": true,
  "bump-patch-for-minor-pre-major": true,
  "changelog-sections": [
    {"type": "feat", "section": "Features"},
    {"type": "fix", "section": "Bug Fixes"},
    {"type": "perf", "section": "Performance Improvements"},
    {"type": "docs", "section": "Documentation", "hidden": false}
  ],
  "extra-files": [
    "src/myproject/__init__.py"
  ]
}
```

### Version in __init__.py

```python
# src/myproject/__init__.py
__version__ = "0.1.0"  # Updated by release-please

__all__ = ["__version__"]
```

### PyPI Publishing: Token-Based

```yaml
# .github/workflows/release.yml
name: Release

on:
  release:
    types: [published]

jobs:
  pypi-publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build distribution
        run: python -m build

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: twine upload dist/*
```

**Setup**:

1. Generate PyPI API token: https://pypi.org/manage/account/token/
2. Add to GitHub Secrets: `PYPI_API_TOKEN`

### PyPI Publishing: Trusted Publisher (Recommended)

**No tokens needed!** GitHub Actions becomes a trusted publisher.

**Setup**:

1. Go to https://pypi.org/manage/account/publishing/
2. Add publisher:
   - PyPI Project: `myproject`
   - Owner: `yourusername`
   - Repository: `myproject`
   - Workflow: `release.yml`
   - Environment: `pypi` (optional)

**Workflow**:
```yaml
name: Release

on:
  release:
    types: [published]

permissions:
  id-token: write  # Required for trusted publishing
  contents: read

jobs:
  pypi-publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/myproject

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build

      - name: Build distribution
        run: python -m build

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
```

**Benefits**:

- No token management
- More secure (scoped to repo)
- Easier rotation
- Recommended by PyPA

### TestPyPI for Validation

```yaml
- name: Publish to TestPyPI
  uses: pypa/gh-action-pypi-publish@release/v1
  with:
    repository-url: https://test.pypi.org/legacy/
```

### Full Release Workflow

```yaml
name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  id-token: write
  contents: write

jobs:
  build:
    name: Build distribution
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Build
        run: |
          pip install build
          python -m build

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/

  publish-pypi:
    name: Publish to PyPI
    needs: build
    runs-on: ubuntu-latest
    environment: pypi
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist/

      - name: Publish
        uses: pypa/gh-action-pypi-publish@release/v1

  github-release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist/

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
```

---

## Container Patterns for Python

### Base Dockerfile (Slim)

```dockerfile
# Dockerfile
FROM python:3.12-slim

# Metadata
LABEL org.opencontainers.image.title="myproject"
LABEL org.opencontainers.image.description="My Python CLI"
LABEL org.opencontainers.image.source="https://github.com/user/myproject"

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Copy project files
COPY pyproject.toml README.md LICENSE ./
COPY src/ ./src/

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir .

# Create non-root user
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD myproject --version || exit 1

# Entry point
ENTRYPOINT ["myproject"]
CMD ["--help"]
```

### Multi-Stage Build

```dockerfile
# Multi-stage Dockerfile
# Stage 1: Builder
FROM python:3.12-slim AS builder

WORKDIR /build

# Install build dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        gcc \
        build-essential \
    && rm -rf /var/lib/apt/lists/*

# Copy source
COPY pyproject.toml README.md ./
COPY src/ ./src/

# Build wheel
RUN pip install --no-cache-dir build && \
    python -m build --wheel

# Stage 2: Runtime
FROM python:3.12-slim

WORKDIR /app

# Copy only wheel from builder
COPY --from=builder /build/dist/*.whl /tmp/

# Install wheel
RUN pip install --no-cache-dir /tmp/*.whl && \
    rm /tmp/*.whl

# Create non-root user
RUN useradd -m -u 1000 appuser
USER appuser

ENTRYPOINT ["myproject"]
CMD ["--help"]
```

### Alpine-Based (Smallest Size)

```dockerfile
# Alpine Dockerfile (smaller but slower builds)
FROM python:3.12-alpine

WORKDIR /app

# Install build dependencies
RUN apk add --no-cache \
        gcc \
        musl-dev \
        libffi-dev \
    && pip install --no-cache-dir --upgrade pip

# Copy and install
COPY pyproject.toml README.md ./
COPY src/ ./src/
RUN pip install --no-cache-dir .

# Cleanup build dependencies
RUN apk del gcc musl-dev libffi-dev

# User and entrypoint
RUN adduser -D -u 1000 appuser
USER appuser

ENTRYPOINT ["myproject"]
```

### Optimized for Production

```dockerfile
# Production Dockerfile
FROM python:3.12-slim

# Prevent Python from writing pyc files
ENV PYTHONDONTWRITEBYTECODE=1
# Prevent Python from buffering stdout/stderr
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Security: Run as non-root
RUN groupadd -r appuser && \
    useradd -r -g appuser -u 1000 appuser

# Install system dependencies
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        ca-certificates \
        tini \
    && rm -rf /var/lib/apt/lists/*

# Copy application
COPY --chown=appuser:appuser pyproject.toml README.md ./
COPY --chown=appuser:appuser src/ ./src/

# Install dependencies
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir . && \
    find /usr/local/lib/python3.12 -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true

USER appuser

# Use tini as init
ENTRYPOINT ["/usr/bin/tini", "--", "myproject"]
CMD ["--help"]
```

### Docker Compose for Development

```yaml
# docker-compose.yml
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: myproject:dev
    volumes:
      - ./src:/app/src
      - ./tests:/app/tests
    environment:
      - MYPROJECT_LOG_LEVEL=debug
    command: ["--help"]

  test:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/app
    command: ["pytest", "tests/"]
```

### GitHub Actions: Build and Push

```yaml
jobs:
  docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

---

## Adapting from Go Patterns

### Translation Table

| Go Pattern | Python Equivalent | Notes |
|------------|------------------|-------|
| `go test ./...` | `pytest tests/` | Recursive test discovery |
| `go test -v -run TestName` | `pytest tests/test_file.py::test_name -v` | Run specific test |
| `go test -cover` | `pytest --cov=src` | Coverage reporting |
| `go vet` | `ruff check` | Linting |
| `gofmt` | `ruff format` | Code formatting |
| `go build` | `python -m build` | Build distribution |
| `go install` | `pip install -e .` | Install package |
| `go mod tidy` | `pip install -e ".[dev]"` | Install dependencies |
| `go mod download` | `pip download -r requirements.txt` | Download deps |
| `go.mod` | `pyproject.toml` | Dependency manifest |
| `go.sum` | `requirements.lock` or `poetry.lock` | Dependency lock file |
| `main.go` | `__main__.py` | Entry point |
| `internal/` | `_internal/` | Private packages |
| `pkg/` | `lib/` or root | Public packages |

### Project Structure Comparison

**Go**:
```
myproject/
├── cmd/
│   └── myproject/
│       └── main.go
├── internal/
│   ├── config/
│   └── service/
└── pkg/
    └── api/
```

**Python**:
```
myproject/
├── src/
│   └── myproject/
│       ├── __main__.py
│       ├── _internal/
│       │   ├── config.py
│       │   └── service.py
│       └── api/
```

### Testing Patterns

**Go Table-Driven Tests**:
```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, -1, -2},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            assert.Equal(t, tt.want, got)
        })
    }
}
```

**Python Parametrized Tests**:
```python
@pytest.mark.parametrize(
    "a,b,expected",
    [
        pytest.param(2, 3, 5, id="positive"),
        pytest.param(-1, -1, -2, id="negative"),
    ],
)
def test_add(a, b, expected):
    result = add(a, b)
    assert result == expected
```

### Build Metadata

**Go (ldflags)**:
```go
// internal/meta/info.go
package meta

var (
    Version   string
    Commit    string
    BuildTime string
)
```

```yaml
# .goreleaser.yaml
builds:
  - ldflags:
      - -X github.com/user/app/internal/meta.Version={{.Version}}
      - -X github.com/user/app/internal/meta.Commit={{.Commit}}
      - -X github.com/user/app/internal/meta.BuildTime={{.Date}}
```

**Python (setuptools-scm or hardcoded)**:
```python
# src/myproject/_version.py
__version__ = "0.1.0"  # Updated by release-please

# src/myproject/meta.py
import sys
from ._version import __version__

def get_build_info():
    return {
        "version": __version__,
        "python_version": sys.version,
        "platform": sys.platform,
    }
```

Or use `setuptools-scm` for git-based versioning:
```toml
[build-system]
requires = ["setuptools>=68", "setuptools-scm>=8"]

[tool.setuptools_scm]
write_to = "src/myproject/_version.py"
```

### Error Handling

**Go**:
```go
if err != nil {
    return fmt.Errorf("failed to read config: %w", err)
}
```

**Python**:
```python
try:
    config = load_config(path)
except FileNotFoundError as e:
    raise ConfigError(f"Failed to read config: {e}") from e
```

### Configuration Patterns

**Go (Cobra + Viper)**:
```go
rootCmd.PersistentFlags().String("config", "", "config file")
viper.BindPFlag("config", rootCmd.PersistentFlags().Lookup("config"))
```

**Python (Click)**:
```python
@click.command()
@click.option("--config", type=click.Path(), help="Config file")
def cli(config):
    if config:
        load_config(config)
```

---

## CLI Framework Comparison

### Click vs Typer vs Argparse

| Feature | Click | Typer | Argparse |
|---------|-------|-------|----------|
| Ease of use | Medium | Easy | Hard |
| Type hints | No | Yes | No |
| Nested commands | Yes | Yes | No |
| Auto docs | Good | Excellent | Basic |
| Testing | Excellent (CliRunner) | Good | Manual |
| Performance | Fast | Fast | Fastest |
| Dependencies | None | Click | Stdlib |

**Recommendation**:

- **Click**: Production-ready, battle-tested, used by Flask
- **Typer**: Modern, type-hint based, great for new projects
- **Argparse**: Only for stdlib-only projects

### Click Example

```python
# src/myproject/cli.py
import click

@click.group()
@click.option("--verbose", is_flag=True, help="Verbose output")
@click.pass_context
def cli(ctx, verbose):
    """My CLI application."""
    ctx.ensure_object(dict)
    ctx.obj["verbose"] = verbose

@cli.command()
@click.argument("name")
@click.option("--greeting", default="Hello", help="Greeting word")
def greet(name, greeting):
    """Greet someone."""
    click.echo(f"{greeting}, {name}!")

@cli.group()
def config():
    """Configuration commands."""
    pass

@config.command("show")
def config_show():
    """Show configuration."""
    click.echo("Config contents here")

if __name__ == "__main__":
    cli()
```

**Usage**:
```bash
$ myproject greet Alice
Hello, Alice!

$ myproject greet Alice --greeting Hi
Hi, Alice!

$ myproject config show
Config contents here
```

### Typer Example

```python
# src/myproject/cli.py
import typer
from typing import Optional

app = typer.Typer()

@app.command()
def greet(
    name: str,
    greeting: str = typer.Option("Hello", help="Greeting word"),
    verbose: bool = typer.Option(False, "--verbose", "-v"),
):
    """Greet someone."""
    if verbose:
        typer.echo(f"Greeting {name} with '{greeting}'")
    typer.echo(f"{greeting}, {name}!")

config_app = typer.Typer()
app.add_typer(config_app, name="config")

@config_app.command("show")
def config_show():
    """Show configuration."""
    typer.echo("Config contents here")

if __name__ == "__main__":
    app()
```

### Testing Click Commands

```python
# tests/test_cli.py
from click.testing import CliRunner
from myproject.cli import cli

def test_greet_command():
    runner = CliRunner()
    result = runner.invoke(cli, ["greet", "Alice"])
    assert result.exit_code == 0
    assert "Hello, Alice!" in result.output

def test_greet_with_custom_greeting():
    runner = CliRunner()
    result = runner.invoke(cli, ["greet", "Alice", "--greeting", "Hi"])
    assert result.exit_code == 0
    assert "Hi, Alice!" in result.output

def test_config_show():
    runner = CliRunner()
    result = runner.invoke(cli, ["config", "show"])
    assert result.exit_code == 0
    assert "Config contents" in result.output
```

---

## Web Framework Patterns

### Django-Specific Patterns

**Project structure**:
```
myproject/
├── manage.py
├── myproject/
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── apps/
│   ├── users/
│   └── api/
└── tests/
```

**Testing**:
```python
# tests/test_views.py
from django.test import TestCase, Client
from django.urls import reverse

class ViewTestCase(TestCase):
    def setUp(self):
        self.client = Client()

    def test_homepage(self):
        response = self.client.get(reverse("home"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "Welcome")
```

**Makefile targets**:
```makefile
.PHONY: django.migrate django.run django.test

django.migrate: ## Run Django migrations
	python manage.py migrate

django.run: ## Run development server
	python manage.py runserver

django.test: ## Run Django tests
	python manage.py test
```

### Flask-Specific Patterns

**Project structure**:
```
myproject/
├── src/
│   └── myproject/
│       ├── __init__.py  # Flask app factory
│       ├── routes/
│       ├── models/
│       └── templates/
└── tests/
    └── test_app.py
```

**App factory**:
```python
# src/myproject/__init__.py
from flask import Flask

def create_app(config=None):
    app = Flask(__name__)

    if config:
        app.config.from_mapping(config)

    # Register blueprints
    from .routes import api
    app.register_blueprint(api.bp)

    return app
```

**Testing**:
```python
# tests/test_app.py
import pytest
from myproject import create_app

@pytest.fixture
def app():
    app = create_app({"TESTING": True})
    yield app

@pytest.fixture
def client(app):
    return app.test_client()

def test_homepage(client):
    response = client.get("/")
    assert response.status_code == 200
    assert b"Welcome" in response.data
```

### FastAPI Patterns

**Project structure**:
```
myproject/
├── src/
│   └── myproject/
│       ├── main.py
│       ├── routers/
│       ├── models/
│       └── schemas/
└── tests/
```

**Testing**:
```python
# tests/test_api.py
from fastapi.testclient import TestClient
from myproject.main import app

client = TestClient(app)

def test_read_root():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Hello World"}
```

---

## Data Science Projects

### Jupyter Notebook Structure

```
myproject/
├── notebooks/
│   ├── 01-data-exploration.ipynb
│   ├── 02-feature-engineering.ipynb
│   └── 03-modeling.ipynb
├── src/
│   └── myproject/
│       ├── data/
│       ├── features/
│       └── models/
├── data/
│   ├── raw/
│   ├── processed/
│   └── external/
└── tests/
```

### Data Versioning with DVC

```bash
# Initialize DVC
dvc init

# Track data
dvc add data/raw/dataset.csv

# Remote storage
dvc remote add -d storage s3://mybucket/dvcstore

# Push data
dvc push
```

**pyproject.toml additions**:
```toml
[project.optional-dependencies]
data = [
    "pandas>=2.0.0",
    "numpy>=1.24.0",
    "scikit-learn>=1.3.0",
    "dvc[s3]>=3.0.0",
]
notebooks = [
    "jupyter>=1.0.0",
    "jupyterlab>=4.0.0",
    "matplotlib>=3.7.0",
    "seaborn>=0.12.0",
]
```

### Makefile for Data Science

```makefile
.PHONY: data.download data.process notebook

data.download: ## Download raw data
	python scripts/download_data.py

data.process: ## Process raw data
	python scripts/process_data.py

notebook: venv ## Start Jupyter Lab
	$(VENV_BIN)/jupyter lab

model.train: ## Train model
	python scripts/train_model.py

model.evaluate: ## Evaluate model
	python scripts/evaluate_model.py
```

### Testing Data Pipelines

```python
# tests/test_data.py
import pandas as pd
import pytest

@pytest.fixture
def sample_data():
    return pd.DataFrame({
        "feature1": [1, 2, 3],
        "feature2": [4, 5, 6],
        "target": [0, 1, 0],
    })

def test_feature_engineering(sample_data):
    result = engineer_features(sample_data)
    assert "feature1_squared" in result.columns
    assert len(result) == len(sample_data)

def test_data_validation(sample_data):
    # Use pandera or great_expectations
    from pandera import DataFrameSchema, Column

    schema = DataFrameSchema({
        "feature1": Column(int),
        "feature2": Column(int),
        "target": Column(int),
    })

    schema.validate(sample_data)
```

---

## Complete Example Project

### Full Project Layout

```
myproject/
├── .github/
│   ├── workflows/
│   │   ├── ci.yml
│   │   └── release.yml
│   └── release-please-config.json
│
├── docs/
│   ├── adr/
│   ├── commands/
│   └── features/
│
├── src/
│   └── myproject/
│       ├── __init__.py
│       ├── __main__.py
│       ├── _version.py
│       ├── cli.py
│       ├── config.py
│       ├── meta.py
│       └── core/
│           ├── __init__.py
│           └── service.py
│
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_cli.py
│   └── core/
│       └── test_service.py
│
├── scripts/
│   └── verify-release.sh
│
├── .gitignore
├── .python-version
├── LICENSE
├── Makefile
├── pyproject.toml
├── README.md
└── SECURITY.md
```

### Complete pyproject.toml

```toml
[project]
name = "myproject"
version = "0.0.0"
description = "A production-ready Python CLI"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
authors = [{name = "Your Name", email = "you@example.com"}]
keywords = ["cli", "automation"]

dependencies = [
    "click>=8.1.0",
    "pyyaml>=6.0.0",
    "rich>=13.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
    "pytest-mock>=3.12.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
]

[project.scripts]
myproject = "myproject.cli:main"

[project.urls]
Homepage = "https://github.com/user/myproject"
Repository = "https://github.com/user/myproject"
Issues = "https://github.com/user/myproject/issues"

[build-system]
requires = ["setuptools>=68.0.0"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "W", "I", "N", "UP", "B", "C4", "SIM", "RUF"]
ignore = ["E501"]

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = ["-ra", "--strict-markers", "-v"]

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
fail_under = 80.0
```

### Sample CLI Implementation

```python
# src/myproject/cli.py
import click
from . import __version__

@click.group()
@click.version_option(version=__version__)
@click.option("--config", type=click.Path(), help="Config file")
@click.pass_context
def cli(ctx, config):
    """My production-ready CLI application."""
    ctx.ensure_object(dict)
    ctx.obj["config"] = config

@cli.command()
@click.argument("message")
@click.option("--upper", is_flag=True, help="Uppercase output")
def echo(message, upper):
    """Echo a message."""
    output = message.upper() if upper else message
    click.echo(output)

@cli.group()
def meta():
    """Metadata commands."""
    pass

@meta.command("info")
def meta_info():
    """Show version info."""
    click.echo(f"Version: {__version__}")

def main():
    cli(obj={})

if __name__ == "__main__":
    main()
```

### Complete GitHub Actions Workflow

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"
      - run: pip install ruff mypy
      - run: ruff check .
      - run: mypy src/

  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ["3.10", "3.11", "3.12"]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"
      - run: pip install -e ".[dev]"
      - run: pytest --cov=src --cov-fail-under=80

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - run: pip install build
      - run: python -m build
      - uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
```

---

## Summary

This chapter provided a complete guide to adapting the CI/CD system for Python projects:

1. **Project Structure**: Src-layout for applications and libraries
2. **Pyproject.toml**: Modern Python project configuration
3. **Testing**: Pytest with parametrize, fixtures, and coverage
4. **Linting**: Ruff as all-in-one linting and formatting
5. **Type Checking**: Mypy or Pyright configuration
6. **Virtual Environments**: venv for simplicity, Poetry for complex projects
7. **Dependencies**: pyproject.toml with optional dependency groups
8. **Makefile**: Complete python.mk for automation
9. **GitHub Actions**: CI workflows with matrix testing
10. **Release Automation**: PyPI publishing with trusted publishers
11. **Containers**: Optimized Dockerfiles for Python
12. **Go → Python**: Direct translation of patterns
13. **CLI Frameworks**: Click vs Typer comparison
14. **Web Frameworks**: Django, Flask, FastAPI patterns
15. **Data Science**: Jupyter, DVC, and data pipeline testing

**Key Takeaways**:

- Use src-layout for proper package isolation
- Ruff replaces black, flake8, isort with better performance
- Pytest parametrize mirrors Go's table-driven tests
- PyPI trusted publishing eliminates token management
- 80% coverage threshold enforced in CI (matching Go)
- Virtual environments with pip are sufficient for most projects
- Click provides production-ready CLI framework

**Next Steps**:

- Clone the example structure
- Adapt Makefile targets to your project
- Set up GitHub Actions workflows
- Configure PyPI trusted publishing
- Implement git hooks for pre-commit checks

Python projects can achieve the same level of automation, quality, and security as the Go-based system documented in this repository.
